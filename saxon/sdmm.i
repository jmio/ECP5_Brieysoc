# 1 "sdmm.c"
# 1 "C:\\Users\\mio\\Desktop\\github\\ECP5_Brieysoc\\saxon//"
# 1 "<built-in>"
# 1 "<command-line>"
# 1 "sdmm.c"
# 31 "sdmm.c"
# 1 "ff.h" 1
# 29 "ff.h"
# 1 "ffconf.h" 1
# 30 "ff.h" 2
# 44 "ff.h"
# 1 "c:\\gccriscv\\8.2.0\\riscv-none-embed\\include\\stdint.h" 1 3
# 12 "c:\\gccriscv\\8.2.0\\riscv-none-embed\\include\\stdint.h" 3
# 1 "c:\\gccriscv\\8.2.0\\riscv-none-embed\\include\\machine\\_default_types.h" 1 3







# 1 "c:\\gccriscv\\8.2.0\\riscv-none-embed\\include\\sys\\features.h" 1 3
# 28 "c:\\gccriscv\\8.2.0\\riscv-none-embed\\include\\sys\\features.h" 3
# 1 "c:\\gccriscv\\8.2.0\\riscv-none-embed\\include\\_newlib_version.h" 1 3
# 29 "c:\\gccriscv\\8.2.0\\riscv-none-embed\\include\\sys\\features.h" 2 3
# 9 "c:\\gccriscv\\8.2.0\\riscv-none-embed\\include\\machine\\_default_types.h" 2 3
# 41 "c:\\gccriscv\\8.2.0\\riscv-none-embed\\include\\machine\\_default_types.h" 3

# 41 "c:\\gccriscv\\8.2.0\\riscv-none-embed\\include\\machine\\_default_types.h" 3
typedef signed char __int8_t;

typedef unsigned char __uint8_t;
# 55 "c:\\gccriscv\\8.2.0\\riscv-none-embed\\include\\machine\\_default_types.h" 3
typedef short int __int16_t;

typedef short unsigned int __uint16_t;
# 77 "c:\\gccriscv\\8.2.0\\riscv-none-embed\\include\\machine\\_default_types.h" 3
typedef long int __int32_t;

typedef long unsigned int __uint32_t;
# 103 "c:\\gccriscv\\8.2.0\\riscv-none-embed\\include\\machine\\_default_types.h" 3
typedef long long int __int64_t;

typedef long long unsigned int __uint64_t;
# 134 "c:\\gccriscv\\8.2.0\\riscv-none-embed\\include\\machine\\_default_types.h" 3
typedef signed char __int_least8_t;

typedef unsigned char __uint_least8_t;
# 160 "c:\\gccriscv\\8.2.0\\riscv-none-embed\\include\\machine\\_default_types.h" 3
typedef short int __int_least16_t;

typedef short unsigned int __uint_least16_t;
# 182 "c:\\gccriscv\\8.2.0\\riscv-none-embed\\include\\machine\\_default_types.h" 3
typedef long int __int_least32_t;

typedef long unsigned int __uint_least32_t;
# 200 "c:\\gccriscv\\8.2.0\\riscv-none-embed\\include\\machine\\_default_types.h" 3
typedef long long int __int_least64_t;

typedef long long unsigned int __uint_least64_t;
# 214 "c:\\gccriscv\\8.2.0\\riscv-none-embed\\include\\machine\\_default_types.h" 3
typedef long long int __intmax_t;







typedef long long unsigned int __uintmax_t;







typedef int __intptr_t;

typedef unsigned int __uintptr_t;
# 13 "c:\\gccriscv\\8.2.0\\riscv-none-embed\\include\\stdint.h" 2 3
# 1 "c:\\gccriscv\\8.2.0\\riscv-none-embed\\include\\sys\\_intsup.h" 1 3
# 35 "c:\\gccriscv\\8.2.0\\riscv-none-embed\\include\\sys\\_intsup.h" 3
       
       
       
       
       
       
       
# 187 "c:\\gccriscv\\8.2.0\\riscv-none-embed\\include\\sys\\_intsup.h" 3
       
       
       
       
       
       
       
# 14 "c:\\gccriscv\\8.2.0\\riscv-none-embed\\include\\stdint.h" 2 3
# 1 "c:\\gccriscv\\8.2.0\\riscv-none-embed\\include\\sys\\_stdint.h" 1 3
# 20 "c:\\gccriscv\\8.2.0\\riscv-none-embed\\include\\sys\\_stdint.h" 3
typedef __int8_t int8_t ;



typedef __uint8_t uint8_t ;







typedef __int16_t int16_t ;



typedef __uint16_t uint16_t ;







typedef __int32_t int32_t ;



typedef __uint32_t uint32_t ;







typedef __int64_t int64_t ;



typedef __uint64_t uint64_t ;






typedef __intmax_t intmax_t;




typedef __uintmax_t uintmax_t;




typedef __intptr_t intptr_t;




typedef __uintptr_t uintptr_t;
# 15 "c:\\gccriscv\\8.2.0\\riscv-none-embed\\include\\stdint.h" 2 3






typedef __int_least8_t int_least8_t;
typedef __uint_least8_t uint_least8_t;




typedef __int_least16_t int_least16_t;
typedef __uint_least16_t uint_least16_t;




typedef __int_least32_t int_least32_t;
typedef __uint_least32_t uint_least32_t;




typedef __int_least64_t int_least64_t;
typedef __uint_least64_t uint_least64_t;
# 51 "c:\\gccriscv\\8.2.0\\riscv-none-embed\\include\\stdint.h" 3
  typedef int int_fast8_t;
  typedef unsigned int uint_fast8_t;
# 61 "c:\\gccriscv\\8.2.0\\riscv-none-embed\\include\\stdint.h" 3
  typedef int int_fast16_t;
  typedef unsigned int uint_fast16_t;
# 71 "c:\\gccriscv\\8.2.0\\riscv-none-embed\\include\\stdint.h" 3
  typedef int int_fast32_t;
  typedef unsigned int uint_fast32_t;
# 81 "c:\\gccriscv\\8.2.0\\riscv-none-embed\\include\\stdint.h" 3
  typedef long long int int_fast64_t;
  typedef long long unsigned int uint_fast64_t;
# 45 "ff.h" 2

# 45 "ff.h"
typedef unsigned int UINT;
typedef unsigned char BYTE;
typedef uint16_t WORD;
typedef uint32_t DWORD;
typedef uint64_t QWORD;
typedef WORD WCHAR;
# 99 "ff.h"
typedef char TCHAR;
# 124 "ff.h"
typedef DWORD FSIZE_t;
typedef DWORD LBA_t;






typedef struct {
 BYTE fs_type;
 BYTE pdrv;
 BYTE n_fats;
 BYTE wflag;
 BYTE fsi_flag;
 WORD id;
 WORD n_rootdir;
 WORD csize;
# 165 "ff.h"
 DWORD n_fatent;
 DWORD fsize;
 LBA_t volbase;
 LBA_t fatbase;
 LBA_t dirbase;
 LBA_t database;



 LBA_t winsect;
 BYTE win[512];
} FATFS;





typedef struct {
 FATFS* fs;
 WORD id;
 BYTE attr;
 BYTE stat;
 DWORD sclust;
 FSIZE_t objsize;
# 199 "ff.h"
} FFOBJID;





typedef struct {
 FFOBJID obj;
 BYTE flag;
 BYTE err;
 FSIZE_t fptr;
 DWORD clust;
 LBA_t sect;
# 220 "ff.h"
 BYTE buf[512];

} FIL;





typedef struct {
 FFOBJID obj;
 DWORD dptr;
 DWORD clust;
 LBA_t sect;
 BYTE* dir;
 BYTE fn[12];




 const TCHAR* pat;

} DIR;





typedef struct {
 FSIZE_t fsize;
 WORD fdate;
 WORD ftime;
 BYTE fattrib;




 TCHAR fname[12 + 1];

} FILINFO;





typedef struct {
 BYTE fmt;
 BYTE n_fat;
 UINT align;
 UINT n_root;
 DWORD au_size;
} MKFS_PARM;





typedef enum {
 FR_OK = 0,
 FR_DISK_ERR,
 FR_INT_ERR,
 FR_NOT_READY,
 FR_NO_FILE,
 FR_NO_PATH,
 FR_INVALID_NAME,
 FR_DENIED,
 FR_EXIST,
 FR_INVALID_OBJECT,
 FR_WRITE_PROTECTED,
 FR_INVALID_DRIVE,
 FR_NOT_ENABLED,
 FR_NO_FILESYSTEM,
 FR_MKFS_ABORTED,
 FR_TIMEOUT,
 FR_LOCKED,
 FR_NOT_ENOUGH_CORE,
 FR_TOO_MANY_OPEN_FILES,
 FR_INVALID_PARAMETER
} FRESULT;






FRESULT f_open (FIL* fp, const TCHAR* path, BYTE mode);
FRESULT f_close (FIL* fp);
FRESULT f_read (FIL* fp, void* buff, UINT btr, UINT* br);
FRESULT f_write (FIL* fp, const void* buff, UINT btw, UINT* bw);
FRESULT f_lseek (FIL* fp, FSIZE_t ofs);
FRESULT f_truncate (FIL* fp);
FRESULT f_sync (FIL* fp);
FRESULT f_opendir (DIR* dp, const TCHAR* path);
FRESULT f_closedir (DIR* dp);
FRESULT f_readdir (DIR* dp, FILINFO* fno);
FRESULT f_findfirst (DIR* dp, FILINFO* fno, const TCHAR* path, const TCHAR* pattern);
FRESULT f_findnext (DIR* dp, FILINFO* fno);
FRESULT f_mkdir (const TCHAR* path);
FRESULT f_unlink (const TCHAR* path);
FRESULT f_rename (const TCHAR* path_old, const TCHAR* path_new);
FRESULT f_stat (const TCHAR* path, FILINFO* fno);
FRESULT f_chmod (const TCHAR* path, BYTE attr, BYTE mask);
FRESULT f_utime (const TCHAR* path, const FILINFO* fno);
FRESULT f_chdir (const TCHAR* path);
FRESULT f_chdrive (const TCHAR* path);
FRESULT f_getcwd (TCHAR* buff, UINT len);
FRESULT f_getfree (const TCHAR* path, DWORD* nclst, FATFS** fatfs);
FRESULT f_getlabel (const TCHAR* path, TCHAR* label, DWORD* vsn);
FRESULT f_setlabel (const TCHAR* label);
FRESULT f_forward (FIL* fp, UINT(*func)(const BYTE*,UINT), UINT btf, UINT* bf);
FRESULT f_expand (FIL* fp, FSIZE_t fsz, BYTE opt);
FRESULT f_mount (FATFS* fs, const TCHAR* path, BYTE opt);
FRESULT f_mkfs (const TCHAR* path, const MKFS_PARM* opt, void* work, UINT len);
FRESULT f_fdisk (BYTE pdrv, const LBA_t ptbl[], void* work);
FRESULT f_setcp (WORD cp);
int f_putc (TCHAR c, FIL* fp);
int f_puts (const TCHAR* str, FIL* cp);
int f_printf (FIL* fp, const TCHAR* str, ...);
TCHAR* f_gets (TCHAR* buff, int len, FIL* fp);
# 32 "sdmm.c" 2
# 1 "diskio.h" 1
# 14 "diskio.h"
typedef BYTE DSTATUS;


typedef enum {
 RES_OK = 0,
 RES_ERROR,
 RES_WRPRT,
 RES_NOTRDY,
 RES_PARERR
} DRESULT;






DSTATUS disk_initialize (BYTE pdrv);
DSTATUS disk_status (BYTE pdrv);
DRESULT disk_read (BYTE pdrv, BYTE* buff, LBA_t sector, UINT count);
DRESULT disk_write (BYTE pdrv, const BYTE* buff, LBA_t sector, UINT count);
DRESULT disk_ioctl (BYTE pdrv, BYTE cmd, void* buff);
# 33 "sdmm.c" 2






# 1 "sdio.h" 1



# 1 "murax.h" 1
# 14 "murax.h"
typedef struct
{
  volatile uint32_t CLEARS_TICKS;
  volatile uint32_t LIMIT;
  volatile uint32_t VALUE;
} Timer_Reg;
typedef struct
{
  volatile uint32_t LIMIT;
} Prescaler_Reg;


typedef struct
{
  volatile uint32_t PENDINGS;
  volatile uint32_t MASKS;
} InterruptCtrl_Reg;



typedef struct
{
  volatile uint32_t INPUT;
  volatile uint32_t OUTPUT;
  volatile uint32_t OUTPUT_ENABLE;
} Gpio_Reg;



enum UartParity {NONE = 0,EVEN = 1,ODD = 2};
enum UartStop {ONE = 0,TWO = 1};

typedef struct
{
  volatile uint32_t DATA;
  volatile uint32_t STATUS;
  volatile uint32_t CLOCK_DIVIDER;
  volatile uint32_t FRAME_CONFIG;
} Uart_Reg;

typedef struct {
 uint32_t dataLength;
 enum UartParity parity;
 enum UartStop stop;
 uint32_t clockDivider;
} Uart_Config;

uint32_t uart_writeAvailability(Uart_Reg *reg);
uint32_t uart_readOccupancy(Uart_Reg *reg);
void uart_write(Uart_Reg *reg, uint32_t data);
int uart_read(Uart_Reg *reg);
void uart_applyConfig(Uart_Reg *reg, Uart_Config *config);


void uart_init();
void uart_pollrx();
void uart_polltx();
int uart_getc();
int uart_putc(char c);
char uart_puts(unsigned char *s);
void _uart_wait();







typedef struct {
 uint32_t hSyncStart ,hSyncEnd;
 uint32_t hColorStart,hColorEnd;

 uint32_t vSyncStart ,vSyncEnd;
 uint32_t vColorStart,vColorEnd;
}Vga_Timing;

static const Vga_Timing vga_h800_v480_r60 = {
    .hSyncStart = 61,
    .hSyncEnd = 857 + 80,
    .hColorStart = 119,
    .hColorEnd = 839 + 80,
    .vSyncStart = 5,
    .vSyncEnd = 525,
    .vColorStart = 35,
    .vColorEnd = 515
};

static const Vga_Timing vga_h640_v480_r60 = {
    .hSyncStart = 96,
    .hSyncEnd = 800,
    .hColorStart = 96 + 16,
    .hColorEnd = 800 - 48,
    .vSyncStart = 2,
    .vSyncEnd = 525,
    .vColorStart = 2 + 10,
    .vColorEnd = 525 - 33
};

static const Vga_Timing vga_simRes = {
    .hSyncStart = 8,
    .hSyncEnd = 70,
    .hColorStart = 16,
    .hColorEnd = 64,
    .vSyncStart = 2,
    .vSyncEnd = 48,
    .vColorStart = 8,
    .vColorEnd = 40
};

static const Vga_Timing vga_simRes_h160_v120 = {
 .hSyncStart = 8,
 .hSyncEnd = 24+160,
 .hColorStart = 16,
 .hColorEnd = 16+160,
 .vSyncStart = 2,
 .vSyncEnd = 10+120,
 .vColorStart = 6,
 .vColorEnd = 6+120
};

typedef struct
{
  volatile uint32_t STATUS;
  volatile uint32_t FRAME_SIZE;
  volatile uint32_t FRAME_BASE;
  volatile uint32_t DUMMY0[13];
  volatile Vga_Timing TIMING;
} Vga_Reg;

uint32_t vga_isBusy(Vga_Reg *reg);
void vga_run(Vga_Reg *reg);
void vga_stop(Vga_Reg *reg);
void vga_init();
void vga_clear();
# 160 "murax.h"
void console_clear();
void console_scroll();
void console_putc(unsigned char c) ;
void console_puts(unsigned char *c) ;
# 180 "murax.h"
extern int syscall0(int callno);


extern void flushDataCache(uint32_t dummy);


void putcon(char c) ;

extern volatile uint32_t irqCount;
# 5 "sdio.h" 2
# 40 "sdmm.c" 2
# 58 "sdmm.c"
static
void dly_us (UINT n)
{
 do {
  (*(volatile uint32_t *)0xF0050048);
# 81 "sdmm.c"
 } while (--n);
}
# 116 "sdmm.c"
static
DSTATUS Stat = 0x01;

static
BYTE CardType;







static
void xmit_mmc (
 const BYTE* buff,
 UINT bc
)
{
 BYTE d;
 BYTE tmp[4];
 (*(volatile uint32_t *)0xF0050040) &= 0xFD;

 do {
  if (bc >= 4) {
   tmp[0] = buff[3];
   tmp[1] = buff[2];
   tmp[2] = buff[1];
   tmp[3] = buff[0];
   (*(volatile uint32_t *)0xF005004C) = *(uint32_t *)tmp;
   (*(volatile uint32_t *)0xF0050050) = 0x20;
   while((*(volatile uint32_t *)0xF0050050));
   buff+=4;
   bc-=4;
  } else {
   d = *buff++;
   (*(volatile uint32_t *)0xF005004C) = d;
   (*(volatile uint32_t *)0xF0050050) = 0x08;
   while((*(volatile uint32_t *)0xF0050050));
   bc--;
  }
 } while (bc);
}







static
void rcvr_mmc (
 BYTE *buff,
 UINT bc
)
{
 BYTE tmp[4];
 (*(volatile uint32_t *)0xF005004C) = 0xFF;

 do {
  if (bc >= 4) {
   (*(volatile uint32_t *)0xF0050050) = 0x20;
   while((*(volatile uint32_t *)0xF0050050));
   *((uint32_t *)tmp) = (*(volatile uint32_t *)0xF005004C);
   *buff++ = tmp[3];
   *buff++ = tmp[2];
   *buff++ = tmp[1];
   *buff++ = tmp[0];
   bc-=4;
  } else {
   (*(volatile uint32_t *)0xF0050050) = 0x08;
   while((*(volatile uint32_t *)0xF0050050));
   *buff++ = (*(volatile uint32_t *)0xF005004C);
   bc--;
  }
 } while(bc);
}







static
int wait_ready (void)
{
 BYTE d;
 UINT tmr;


 for (tmr = 50000; tmr; tmr--) {
  rcvr_mmc(&d, 1);
  if (d == 0xFF) break;
  dly_us(10);
 }

 return tmr ? 1 : 0;
}







static
void deselect (void)
{
 BYTE d;

 (*(volatile uint32_t *)0xF0050040) |= 0x08;
 rcvr_mmc(&d, 1);
}







static
int select (void)
{
 BYTE d;

 (*(volatile uint32_t *)0xF0050040) &= 0xF7;
 rcvr_mmc(&d, 1);
 if (wait_ready()) return 1;

 deselect();
 return 0;
}







static
int rcvr_datablock (
 BYTE *buff,
 UINT btr
)
{
 BYTE d[2];
 UINT tmr;


 for (tmr = 100000; tmr; tmr--) {
  rcvr_mmc(d, 1);
  if (d[0] != 0xFF) break;

  dly_us(1);
 }
 if (d[0] != 0xFE) return 0;

 rcvr_mmc(buff, btr);
 rcvr_mmc(d, 2);

 return 1;
}







static
int xmit_datablock (
 const BYTE *buff,
 BYTE token
)
{
 BYTE d[2];


 if (!wait_ready()) return 0;

 d[0] = token;
 xmit_mmc(d, 1);
 if (token != 0xFD) {
  xmit_mmc(buff, 512);
  rcvr_mmc(d, 2);
  rcvr_mmc(d, 1);
  if ((d[0] & 0x1F) != 0x05)
   return 0;
 }

 return 1;
}







static
BYTE send_cmd (
 BYTE cmd,
 DWORD arg
)
{
 BYTE n, d, buf[6];


 if (cmd & 0x80) {
  cmd &= 0x7F;
  n = send_cmd((55), 0);
  if (n > 1) return n;
 }


 if (cmd != (12)) {
  deselect();
  if (!select()) return 0xFF;
 }


 buf[0] = 0x40 | cmd;
 buf[1] = (BYTE)(arg >> 24);
 buf[2] = (BYTE)(arg >> 16);
 buf[3] = (BYTE)(arg >> 8);
 buf[4] = (BYTE)arg;
 n = 0x01;
 if (cmd == (0)) n = 0x95;
 if (cmd == (8)) n = 0x87;
 buf[5] = n;
 xmit_mmc(buf, 6);


 if (cmd == (12)) rcvr_mmc(&d, 1);
 n = 10;
 do
  rcvr_mmc(&d, 1);
 while ((d & 0x80) && --n);

 return d;
}
# 371 "sdmm.c"
DSTATUS disk_status (
 BYTE drv
)
{
 if (drv) return 0x01;

 return Stat;
}







DSTATUS disk_initialize (
 BYTE drv
)
{
 BYTE n, ty, cmd, buf[4];
 UINT tmr;
 DSTATUS s;


 if (drv) return RES_NOTRDY;

 dly_us(10000);
 (*(volatile uint32_t *)0xF0050044) |= 0x08; (*(volatile uint32_t *)0xF0050040) |= 0x08;
 (*(volatile uint32_t *)0xF0050044) |= 0x04; (*(volatile uint32_t *)0xF0050040) &= 0xFB;
 (*(volatile uint32_t *)0xF0050044) |= 0x02;
 ;

 for (n = 10; n; n--) rcvr_mmc(buf, 1);

 ty = 0;
 if (send_cmd((0), 0) == 1) {
  if (send_cmd((8), 0x1AA) == 1) {
   rcvr_mmc(buf, 4);
   if (buf[2] == 0x01 && buf[3] == 0xAA) {
    for (tmr = 1000; tmr; tmr--) {
     if (send_cmd((0x80+41), 1UL << 30) == 0) break;
     dly_us(1000);
    }
    if (tmr && send_cmd((58), 0) == 0) {
     rcvr_mmc(buf, 4);
     ty = (buf[0] & 0x40) ? 0x04 | 0x08 : 0x04;
    }
   }
  } else {
   if (send_cmd((0x80+41), 0) <= 1) {
    ty = 0x02; cmd = (0x80+41);
   } else {
    ty = 0x01; cmd = (1);
   }
   for (tmr = 1000; tmr; tmr--) {
    if (send_cmd(cmd, 0) == 0) break;
    dly_us(1000);
   }
   if (!tmr || send_cmd((16), 512) != 0)
    ty = 0;
  }
 }
 CardType = ty;
 s = ty ? 0 : 0x01;
 Stat = s;

 deselect();

 return s;
}







DRESULT disk_read (
 BYTE drv,
 BYTE *buff,
 LBA_t sector,
 UINT count
)
{
 BYTE cmd;
 DWORD sect = (DWORD)sector;


 if (disk_status(drv) & 0x01) return RES_NOTRDY;
 if (!(CardType & 0x08)) sect *= 512;

 cmd = count > 1 ? (18) : (17);
 if (send_cmd(cmd, sect) == 0) {
  do {
   if (!rcvr_datablock(buff, 512)) break;
   buff += 512;
  } while (--count);
  if (cmd == (18)) send_cmd((12), 0);
 }
 deselect();

 return count ? RES_ERROR : RES_OK;
}







DRESULT disk_write (
 BYTE drv,
 const BYTE *buff,
 LBA_t sector,
 UINT count
)
{
 DWORD sect = (DWORD)sector;


 if (disk_status(drv) & 0x01) return RES_NOTRDY;
 if (!(CardType & 0x08)) sect *= 512;

 if (count == 1) {
  if ((send_cmd((24), sect) == 0)
   && xmit_datablock(buff, 0xFE))
   count = 0;
 }
 else {
  if (CardType & (0x02|0x04)) send_cmd((0x80+23), count);
  if (send_cmd((25), sect) == 0) {
   do {
    if (!xmit_datablock(buff, 0xFC)) break;
    buff += 512;
   } while (--count);
   if (!xmit_datablock(0, 0xFD))
    count = 1;
  }
 }
 deselect();

 return count ? RES_ERROR : RES_OK;
}






DRESULT disk_ioctl (
 BYTE drv,
 BYTE ctrl,
 void *buff
)
{
 DRESULT res;
 BYTE n, csd[16];
 DWORD cs;


 if (disk_status(drv) & 0x01) return RES_NOTRDY;

 res = RES_ERROR;
 switch (ctrl) {
  case 0 :
   if (select()) res = RES_OK;
   break;

  case 1 :
   if ((send_cmd((9), 0) == 0) && rcvr_datablock(csd, 16)) {
    if ((csd[0] >> 6) == 1) {
     cs = csd[9] + ((WORD)csd[8] << 8) + ((DWORD)(csd[7] & 63) << 16) + 1;
     *(LBA_t*)buff = cs << 10;
    } else {
     n = (csd[5] & 15) + ((csd[10] & 128) >> 7) + ((csd[9] & 3) << 1) + 2;
     cs = (csd[8] >> 6) + ((WORD)csd[7] << 2) + ((WORD)(csd[6] & 3) << 10) + 1;
     *(LBA_t*)buff = cs << (n - 9);
    }
    res = RES_OK;
   }
   break;

  case 3 :
   *(DWORD*)buff = 128;
   res = RES_OK;
   break;

  default:
   res = RES_PARERR;
 }

 deselect();

 return res;
}
